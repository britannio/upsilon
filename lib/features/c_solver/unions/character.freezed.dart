// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'character.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$CharacterTearOff {
  const _$CharacterTearOff();

  _Red red() {
    return const _Red();
  }

  _Green green() {
    return const _Green();
  }

  _Yellow yellow() {
    return const _Yellow();
  }

  _Purple purple() {
    return const _Purple();
  }

  _Blue blue() {
    return const _Blue();
  }

  _White white() {
    return const _White();
  }
}

/// @nodoc
const $Character = _$CharacterTearOff();

/// @nodoc
mixin _$Character {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterCopyWith<$Res> {
  factory $CharacterCopyWith(Character value, $Res Function(Character) then) =
      _$CharacterCopyWithImpl<$Res>;
}

/// @nodoc
class _$CharacterCopyWithImpl<$Res> implements $CharacterCopyWith<$Res> {
  _$CharacterCopyWithImpl(this._value, this._then);

  final Character _value;
  // ignore: unused_field
  final $Res Function(Character) _then;
}

/// @nodoc
abstract class _$RedCopyWith<$Res> {
  factory _$RedCopyWith(_Red value, $Res Function(_Red) then) =
      __$RedCopyWithImpl<$Res>;
}

/// @nodoc
class __$RedCopyWithImpl<$Res> extends _$CharacterCopyWithImpl<$Res>
    implements _$RedCopyWith<$Res> {
  __$RedCopyWithImpl(_Red _value, $Res Function(_Red) _then)
      : super(_value, (v) => _then(v as _Red));

  @override
  _Red get _value => super._value as _Red;
}

/// @nodoc

class _$_Red implements _Red {
  const _$_Red();

  @override
  String toString() {
    return 'Character.red()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Red);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) {
    return red();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) {
    if (red != null) {
      return red();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) {
    return red(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) {
    if (red != null) {
      return red(this);
    }
    return orElse();
  }
}

abstract class _Red implements Character {
  const factory _Red() = _$_Red;
}

/// @nodoc
abstract class _$GreenCopyWith<$Res> {
  factory _$GreenCopyWith(_Green value, $Res Function(_Green) then) =
      __$GreenCopyWithImpl<$Res>;
}

/// @nodoc
class __$GreenCopyWithImpl<$Res> extends _$CharacterCopyWithImpl<$Res>
    implements _$GreenCopyWith<$Res> {
  __$GreenCopyWithImpl(_Green _value, $Res Function(_Green) _then)
      : super(_value, (v) => _then(v as _Green));

  @override
  _Green get _value => super._value as _Green;
}

/// @nodoc

class _$_Green implements _Green {
  const _$_Green();

  @override
  String toString() {
    return 'Character.green()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Green);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) {
    return green();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) {
    if (green != null) {
      return green();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) {
    return green(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) {
    if (green != null) {
      return green(this);
    }
    return orElse();
  }
}

abstract class _Green implements Character {
  const factory _Green() = _$_Green;
}

/// @nodoc
abstract class _$YellowCopyWith<$Res> {
  factory _$YellowCopyWith(_Yellow value, $Res Function(_Yellow) then) =
      __$YellowCopyWithImpl<$Res>;
}

/// @nodoc
class __$YellowCopyWithImpl<$Res> extends _$CharacterCopyWithImpl<$Res>
    implements _$YellowCopyWith<$Res> {
  __$YellowCopyWithImpl(_Yellow _value, $Res Function(_Yellow) _then)
      : super(_value, (v) => _then(v as _Yellow));

  @override
  _Yellow get _value => super._value as _Yellow;
}

/// @nodoc

class _$_Yellow implements _Yellow {
  const _$_Yellow();

  @override
  String toString() {
    return 'Character.yellow()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Yellow);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) {
    return yellow();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) {
    if (yellow != null) {
      return yellow();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) {
    return yellow(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) {
    if (yellow != null) {
      return yellow(this);
    }
    return orElse();
  }
}

abstract class _Yellow implements Character {
  const factory _Yellow() = _$_Yellow;
}

/// @nodoc
abstract class _$PurpleCopyWith<$Res> {
  factory _$PurpleCopyWith(_Purple value, $Res Function(_Purple) then) =
      __$PurpleCopyWithImpl<$Res>;
}

/// @nodoc
class __$PurpleCopyWithImpl<$Res> extends _$CharacterCopyWithImpl<$Res>
    implements _$PurpleCopyWith<$Res> {
  __$PurpleCopyWithImpl(_Purple _value, $Res Function(_Purple) _then)
      : super(_value, (v) => _then(v as _Purple));

  @override
  _Purple get _value => super._value as _Purple;
}

/// @nodoc

class _$_Purple implements _Purple {
  const _$_Purple();

  @override
  String toString() {
    return 'Character.purple()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Purple);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) {
    return purple();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) {
    if (purple != null) {
      return purple();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) {
    return purple(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) {
    if (purple != null) {
      return purple(this);
    }
    return orElse();
  }
}

abstract class _Purple implements Character {
  const factory _Purple() = _$_Purple;
}

/// @nodoc
abstract class _$BlueCopyWith<$Res> {
  factory _$BlueCopyWith(_Blue value, $Res Function(_Blue) then) =
      __$BlueCopyWithImpl<$Res>;
}

/// @nodoc
class __$BlueCopyWithImpl<$Res> extends _$CharacterCopyWithImpl<$Res>
    implements _$BlueCopyWith<$Res> {
  __$BlueCopyWithImpl(_Blue _value, $Res Function(_Blue) _then)
      : super(_value, (v) => _then(v as _Blue));

  @override
  _Blue get _value => super._value as _Blue;
}

/// @nodoc

class _$_Blue implements _Blue {
  const _$_Blue();

  @override
  String toString() {
    return 'Character.blue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Blue);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) {
    return blue();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) {
    if (blue != null) {
      return blue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) {
    return blue(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) {
    if (blue != null) {
      return blue(this);
    }
    return orElse();
  }
}

abstract class _Blue implements Character {
  const factory _Blue() = _$_Blue;
}

/// @nodoc
abstract class _$WhiteCopyWith<$Res> {
  factory _$WhiteCopyWith(_White value, $Res Function(_White) then) =
      __$WhiteCopyWithImpl<$Res>;
}

/// @nodoc
class __$WhiteCopyWithImpl<$Res> extends _$CharacterCopyWithImpl<$Res>
    implements _$WhiteCopyWith<$Res> {
  __$WhiteCopyWithImpl(_White _value, $Res Function(_White) _then)
      : super(_value, (v) => _then(v as _White));

  @override
  _White get _value => super._value as _White;
}

/// @nodoc

class _$_White implements _White {
  const _$_White();

  @override
  String toString() {
    return 'Character.white()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _White);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() red,
    required TResult Function() green,
    required TResult Function() yellow,
    required TResult Function() purple,
    required TResult Function() blue,
    required TResult Function() white,
  }) {
    return white();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? red,
    TResult Function()? green,
    TResult Function()? yellow,
    TResult Function()? purple,
    TResult Function()? blue,
    TResult Function()? white,
    required TResult orElse(),
  }) {
    if (white != null) {
      return white();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Red value) red,
    required TResult Function(_Green value) green,
    required TResult Function(_Yellow value) yellow,
    required TResult Function(_Purple value) purple,
    required TResult Function(_Blue value) blue,
    required TResult Function(_White value) white,
  }) {
    return white(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Red value)? red,
    TResult Function(_Green value)? green,
    TResult Function(_Yellow value)? yellow,
    TResult Function(_Purple value)? purple,
    TResult Function(_Blue value)? blue,
    TResult Function(_White value)? white,
    required TResult orElse(),
  }) {
    if (white != null) {
      return white(this);
    }
    return orElse();
  }
}

abstract class _White implements Character {
  const factory _White() = _$_White;
}
