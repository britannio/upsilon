// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'weapon.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$WeaponTearOff {
  const _$WeaponTearOff();

  _Candlestick candlestick() {
    return const _Candlestick();
  }

  _Knife knife() {
    return const _Knife();
  }

  _LeadPipe leadPipe() {
    return const _LeadPipe();
  }

  _Revolver revolver() {
    return const _Revolver();
  }

  _Rope rope() {
    return const _Rope();
  }

  _Wrench wrench() {
    return const _Wrench();
  }
}

/// @nodoc
const $Weapon = _$WeaponTearOff();

/// @nodoc
mixin _$Weapon {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WeaponCopyWith<$Res> {
  factory $WeaponCopyWith(Weapon value, $Res Function(Weapon) then) =
      _$WeaponCopyWithImpl<$Res>;
}

/// @nodoc
class _$WeaponCopyWithImpl<$Res> implements $WeaponCopyWith<$Res> {
  _$WeaponCopyWithImpl(this._value, this._then);

  final Weapon _value;
  // ignore: unused_field
  final $Res Function(Weapon) _then;
}

/// @nodoc
abstract class _$CandlestickCopyWith<$Res> {
  factory _$CandlestickCopyWith(
          _Candlestick value, $Res Function(_Candlestick) then) =
      __$CandlestickCopyWithImpl<$Res>;
}

/// @nodoc
class __$CandlestickCopyWithImpl<$Res> extends _$WeaponCopyWithImpl<$Res>
    implements _$CandlestickCopyWith<$Res> {
  __$CandlestickCopyWithImpl(
      _Candlestick _value, $Res Function(_Candlestick) _then)
      : super(_value, (v) => _then(v as _Candlestick));

  @override
  _Candlestick get _value => super._value as _Candlestick;
}

/// @nodoc

class _$_Candlestick implements _Candlestick {
  const _$_Candlestick();

  @override
  String toString() {
    return 'Weapon.candlestick()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Candlestick);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) {
    return candlestick();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) {
    if (candlestick != null) {
      return candlestick();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) {
    return candlestick(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) {
    if (candlestick != null) {
      return candlestick(this);
    }
    return orElse();
  }
}

abstract class _Candlestick implements Weapon {
  const factory _Candlestick() = _$_Candlestick;
}

/// @nodoc
abstract class _$KnifeCopyWith<$Res> {
  factory _$KnifeCopyWith(_Knife value, $Res Function(_Knife) then) =
      __$KnifeCopyWithImpl<$Res>;
}

/// @nodoc
class __$KnifeCopyWithImpl<$Res> extends _$WeaponCopyWithImpl<$Res>
    implements _$KnifeCopyWith<$Res> {
  __$KnifeCopyWithImpl(_Knife _value, $Res Function(_Knife) _then)
      : super(_value, (v) => _then(v as _Knife));

  @override
  _Knife get _value => super._value as _Knife;
}

/// @nodoc

class _$_Knife implements _Knife {
  const _$_Knife();

  @override
  String toString() {
    return 'Weapon.knife()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Knife);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) {
    return knife();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) {
    if (knife != null) {
      return knife();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) {
    return knife(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) {
    if (knife != null) {
      return knife(this);
    }
    return orElse();
  }
}

abstract class _Knife implements Weapon {
  const factory _Knife() = _$_Knife;
}

/// @nodoc
abstract class _$LeadPipeCopyWith<$Res> {
  factory _$LeadPipeCopyWith(_LeadPipe value, $Res Function(_LeadPipe) then) =
      __$LeadPipeCopyWithImpl<$Res>;
}

/// @nodoc
class __$LeadPipeCopyWithImpl<$Res> extends _$WeaponCopyWithImpl<$Res>
    implements _$LeadPipeCopyWith<$Res> {
  __$LeadPipeCopyWithImpl(_LeadPipe _value, $Res Function(_LeadPipe) _then)
      : super(_value, (v) => _then(v as _LeadPipe));

  @override
  _LeadPipe get _value => super._value as _LeadPipe;
}

/// @nodoc

class _$_LeadPipe implements _LeadPipe {
  const _$_LeadPipe();

  @override
  String toString() {
    return 'Weapon.leadPipe()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LeadPipe);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) {
    return leadPipe();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) {
    if (leadPipe != null) {
      return leadPipe();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) {
    return leadPipe(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) {
    if (leadPipe != null) {
      return leadPipe(this);
    }
    return orElse();
  }
}

abstract class _LeadPipe implements Weapon {
  const factory _LeadPipe() = _$_LeadPipe;
}

/// @nodoc
abstract class _$RevolverCopyWith<$Res> {
  factory _$RevolverCopyWith(_Revolver value, $Res Function(_Revolver) then) =
      __$RevolverCopyWithImpl<$Res>;
}

/// @nodoc
class __$RevolverCopyWithImpl<$Res> extends _$WeaponCopyWithImpl<$Res>
    implements _$RevolverCopyWith<$Res> {
  __$RevolverCopyWithImpl(_Revolver _value, $Res Function(_Revolver) _then)
      : super(_value, (v) => _then(v as _Revolver));

  @override
  _Revolver get _value => super._value as _Revolver;
}

/// @nodoc

class _$_Revolver implements _Revolver {
  const _$_Revolver();

  @override
  String toString() {
    return 'Weapon.revolver()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Revolver);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) {
    return revolver();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) {
    if (revolver != null) {
      return revolver();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) {
    return revolver(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) {
    if (revolver != null) {
      return revolver(this);
    }
    return orElse();
  }
}

abstract class _Revolver implements Weapon {
  const factory _Revolver() = _$_Revolver;
}

/// @nodoc
abstract class _$RopeCopyWith<$Res> {
  factory _$RopeCopyWith(_Rope value, $Res Function(_Rope) then) =
      __$RopeCopyWithImpl<$Res>;
}

/// @nodoc
class __$RopeCopyWithImpl<$Res> extends _$WeaponCopyWithImpl<$Res>
    implements _$RopeCopyWith<$Res> {
  __$RopeCopyWithImpl(_Rope _value, $Res Function(_Rope) _then)
      : super(_value, (v) => _then(v as _Rope));

  @override
  _Rope get _value => super._value as _Rope;
}

/// @nodoc

class _$_Rope implements _Rope {
  const _$_Rope();

  @override
  String toString() {
    return 'Weapon.rope()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Rope);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) {
    return rope();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) {
    if (rope != null) {
      return rope();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) {
    return rope(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) {
    if (rope != null) {
      return rope(this);
    }
    return orElse();
  }
}

abstract class _Rope implements Weapon {
  const factory _Rope() = _$_Rope;
}

/// @nodoc
abstract class _$WrenchCopyWith<$Res> {
  factory _$WrenchCopyWith(_Wrench value, $Res Function(_Wrench) then) =
      __$WrenchCopyWithImpl<$Res>;
}

/// @nodoc
class __$WrenchCopyWithImpl<$Res> extends _$WeaponCopyWithImpl<$Res>
    implements _$WrenchCopyWith<$Res> {
  __$WrenchCopyWithImpl(_Wrench _value, $Res Function(_Wrench) _then)
      : super(_value, (v) => _then(v as _Wrench));

  @override
  _Wrench get _value => super._value as _Wrench;
}

/// @nodoc

class _$_Wrench implements _Wrench {
  const _$_Wrench();

  @override
  String toString() {
    return 'Weapon.wrench()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Wrench);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() candlestick,
    required TResult Function() knife,
    required TResult Function() leadPipe,
    required TResult Function() revolver,
    required TResult Function() rope,
    required TResult Function() wrench,
  }) {
    return wrench();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? candlestick,
    TResult Function()? knife,
    TResult Function()? leadPipe,
    TResult Function()? revolver,
    TResult Function()? rope,
    TResult Function()? wrench,
    required TResult orElse(),
  }) {
    if (wrench != null) {
      return wrench();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Candlestick value) candlestick,
    required TResult Function(_Knife value) knife,
    required TResult Function(_LeadPipe value) leadPipe,
    required TResult Function(_Revolver value) revolver,
    required TResult Function(_Rope value) rope,
    required TResult Function(_Wrench value) wrench,
  }) {
    return wrench(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Candlestick value)? candlestick,
    TResult Function(_Knife value)? knife,
    TResult Function(_LeadPipe value)? leadPipe,
    TResult Function(_Revolver value)? revolver,
    TResult Function(_Rope value)? rope,
    TResult Function(_Wrench value)? wrench,
    required TResult orElse(),
  }) {
    if (wrench != null) {
      return wrench(this);
    }
    return orElse();
  }
}

abstract class _Wrench implements Weapon {
  const factory _Wrench() = _$_Wrench;
}
