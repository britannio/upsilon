// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'room.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RoomTearOff {
  const _$RoomTearOff();

  _Kitchen kitchen() {
    return const _Kitchen();
  }

  _Ballroom ballroom() {
    return const _Ballroom();
  }

  _Conservatory conservatory() {
    return const _Conservatory();
  }

  _DiningRoom diningRoom() {
    return const _DiningRoom();
  }

  _Lounge lounge() {
    return const _Lounge();
  }

  _Hall hall() {
    return const _Hall();
  }

  _Study study() {
    return const _Study();
  }

  _Library library() {
    return const _Library();
  }

  _Billiard billiard() {
    return const _Billiard();
  }
}

/// @nodoc
const $Room = _$RoomTearOff();

/// @nodoc
mixin _$Room {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RoomCopyWith<$Res> {
  factory $RoomCopyWith(Room value, $Res Function(Room) then) =
      _$RoomCopyWithImpl<$Res>;
}

/// @nodoc
class _$RoomCopyWithImpl<$Res> implements $RoomCopyWith<$Res> {
  _$RoomCopyWithImpl(this._value, this._then);

  final Room _value;
  // ignore: unused_field
  final $Res Function(Room) _then;
}

/// @nodoc
abstract class _$KitchenCopyWith<$Res> {
  factory _$KitchenCopyWith(_Kitchen value, $Res Function(_Kitchen) then) =
      __$KitchenCopyWithImpl<$Res>;
}

/// @nodoc
class __$KitchenCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$KitchenCopyWith<$Res> {
  __$KitchenCopyWithImpl(_Kitchen _value, $Res Function(_Kitchen) _then)
      : super(_value, (v) => _then(v as _Kitchen));

  @override
  _Kitchen get _value => super._value as _Kitchen;
}

/// @nodoc

class _$_Kitchen implements _Kitchen {
  const _$_Kitchen();

  @override
  String toString() {
    return 'Room.kitchen()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Kitchen);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return kitchen();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (kitchen != null) {
      return kitchen();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return kitchen(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (kitchen != null) {
      return kitchen(this);
    }
    return orElse();
  }
}

abstract class _Kitchen implements Room {
  const factory _Kitchen() = _$_Kitchen;
}

/// @nodoc
abstract class _$BallroomCopyWith<$Res> {
  factory _$BallroomCopyWith(_Ballroom value, $Res Function(_Ballroom) then) =
      __$BallroomCopyWithImpl<$Res>;
}

/// @nodoc
class __$BallroomCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$BallroomCopyWith<$Res> {
  __$BallroomCopyWithImpl(_Ballroom _value, $Res Function(_Ballroom) _then)
      : super(_value, (v) => _then(v as _Ballroom));

  @override
  _Ballroom get _value => super._value as _Ballroom;
}

/// @nodoc

class _$_Ballroom implements _Ballroom {
  const _$_Ballroom();

  @override
  String toString() {
    return 'Room.ballroom()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Ballroom);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return ballroom();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (ballroom != null) {
      return ballroom();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return ballroom(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (ballroom != null) {
      return ballroom(this);
    }
    return orElse();
  }
}

abstract class _Ballroom implements Room {
  const factory _Ballroom() = _$_Ballroom;
}

/// @nodoc
abstract class _$ConservatoryCopyWith<$Res> {
  factory _$ConservatoryCopyWith(
          _Conservatory value, $Res Function(_Conservatory) then) =
      __$ConservatoryCopyWithImpl<$Res>;
}

/// @nodoc
class __$ConservatoryCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$ConservatoryCopyWith<$Res> {
  __$ConservatoryCopyWithImpl(
      _Conservatory _value, $Res Function(_Conservatory) _then)
      : super(_value, (v) => _then(v as _Conservatory));

  @override
  _Conservatory get _value => super._value as _Conservatory;
}

/// @nodoc

class _$_Conservatory implements _Conservatory {
  const _$_Conservatory();

  @override
  String toString() {
    return 'Room.conservatory()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Conservatory);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return conservatory();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (conservatory != null) {
      return conservatory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return conservatory(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (conservatory != null) {
      return conservatory(this);
    }
    return orElse();
  }
}

abstract class _Conservatory implements Room {
  const factory _Conservatory() = _$_Conservatory;
}

/// @nodoc
abstract class _$DiningRoomCopyWith<$Res> {
  factory _$DiningRoomCopyWith(
          _DiningRoom value, $Res Function(_DiningRoom) then) =
      __$DiningRoomCopyWithImpl<$Res>;
}

/// @nodoc
class __$DiningRoomCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$DiningRoomCopyWith<$Res> {
  __$DiningRoomCopyWithImpl(
      _DiningRoom _value, $Res Function(_DiningRoom) _then)
      : super(_value, (v) => _then(v as _DiningRoom));

  @override
  _DiningRoom get _value => super._value as _DiningRoom;
}

/// @nodoc

class _$_DiningRoom implements _DiningRoom {
  const _$_DiningRoom();

  @override
  String toString() {
    return 'Room.diningRoom()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DiningRoom);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return diningRoom();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (diningRoom != null) {
      return diningRoom();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return diningRoom(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (diningRoom != null) {
      return diningRoom(this);
    }
    return orElse();
  }
}

abstract class _DiningRoom implements Room {
  const factory _DiningRoom() = _$_DiningRoom;
}

/// @nodoc
abstract class _$LoungeCopyWith<$Res> {
  factory _$LoungeCopyWith(_Lounge value, $Res Function(_Lounge) then) =
      __$LoungeCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoungeCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$LoungeCopyWith<$Res> {
  __$LoungeCopyWithImpl(_Lounge _value, $Res Function(_Lounge) _then)
      : super(_value, (v) => _then(v as _Lounge));

  @override
  _Lounge get _value => super._value as _Lounge;
}

/// @nodoc

class _$_Lounge implements _Lounge {
  const _$_Lounge();

  @override
  String toString() {
    return 'Room.lounge()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Lounge);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return lounge();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (lounge != null) {
      return lounge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return lounge(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (lounge != null) {
      return lounge(this);
    }
    return orElse();
  }
}

abstract class _Lounge implements Room {
  const factory _Lounge() = _$_Lounge;
}

/// @nodoc
abstract class _$HallCopyWith<$Res> {
  factory _$HallCopyWith(_Hall value, $Res Function(_Hall) then) =
      __$HallCopyWithImpl<$Res>;
}

/// @nodoc
class __$HallCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$HallCopyWith<$Res> {
  __$HallCopyWithImpl(_Hall _value, $Res Function(_Hall) _then)
      : super(_value, (v) => _then(v as _Hall));

  @override
  _Hall get _value => super._value as _Hall;
}

/// @nodoc

class _$_Hall implements _Hall {
  const _$_Hall();

  @override
  String toString() {
    return 'Room.hall()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Hall);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return hall();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (hall != null) {
      return hall();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return hall(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (hall != null) {
      return hall(this);
    }
    return orElse();
  }
}

abstract class _Hall implements Room {
  const factory _Hall() = _$_Hall;
}

/// @nodoc
abstract class _$StudyCopyWith<$Res> {
  factory _$StudyCopyWith(_Study value, $Res Function(_Study) then) =
      __$StudyCopyWithImpl<$Res>;
}

/// @nodoc
class __$StudyCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$StudyCopyWith<$Res> {
  __$StudyCopyWithImpl(_Study _value, $Res Function(_Study) _then)
      : super(_value, (v) => _then(v as _Study));

  @override
  _Study get _value => super._value as _Study;
}

/// @nodoc

class _$_Study implements _Study {
  const _$_Study();

  @override
  String toString() {
    return 'Room.study()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Study);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return study();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (study != null) {
      return study();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return study(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (study != null) {
      return study(this);
    }
    return orElse();
  }
}

abstract class _Study implements Room {
  const factory _Study() = _$_Study;
}

/// @nodoc
abstract class _$LibraryCopyWith<$Res> {
  factory _$LibraryCopyWith(_Library value, $Res Function(_Library) then) =
      __$LibraryCopyWithImpl<$Res>;
}

/// @nodoc
class __$LibraryCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$LibraryCopyWith<$Res> {
  __$LibraryCopyWithImpl(_Library _value, $Res Function(_Library) _then)
      : super(_value, (v) => _then(v as _Library));

  @override
  _Library get _value => super._value as _Library;
}

/// @nodoc

class _$_Library implements _Library {
  const _$_Library();

  @override
  String toString() {
    return 'Room.library()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Library);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return library();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (library != null) {
      return library();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return library(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (library != null) {
      return library(this);
    }
    return orElse();
  }
}

abstract class _Library implements Room {
  const factory _Library() = _$_Library;
}

/// @nodoc
abstract class _$BilliardCopyWith<$Res> {
  factory _$BilliardCopyWith(_Billiard value, $Res Function(_Billiard) then) =
      __$BilliardCopyWithImpl<$Res>;
}

/// @nodoc
class __$BilliardCopyWithImpl<$Res> extends _$RoomCopyWithImpl<$Res>
    implements _$BilliardCopyWith<$Res> {
  __$BilliardCopyWithImpl(_Billiard _value, $Res Function(_Billiard) _then)
      : super(_value, (v) => _then(v as _Billiard));

  @override
  _Billiard get _value => super._value as _Billiard;
}

/// @nodoc

class _$_Billiard implements _Billiard {
  const _$_Billiard();

  @override
  String toString() {
    return 'Room.billiard()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Billiard);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() kitchen,
    required TResult Function() ballroom,
    required TResult Function() conservatory,
    required TResult Function() diningRoom,
    required TResult Function() lounge,
    required TResult Function() hall,
    required TResult Function() study,
    required TResult Function() library,
    required TResult Function() billiard,
  }) {
    return billiard();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? kitchen,
    TResult Function()? ballroom,
    TResult Function()? conservatory,
    TResult Function()? diningRoom,
    TResult Function()? lounge,
    TResult Function()? hall,
    TResult Function()? study,
    TResult Function()? library,
    TResult Function()? billiard,
    required TResult orElse(),
  }) {
    if (billiard != null) {
      return billiard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Kitchen value) kitchen,
    required TResult Function(_Ballroom value) ballroom,
    required TResult Function(_Conservatory value) conservatory,
    required TResult Function(_DiningRoom value) diningRoom,
    required TResult Function(_Lounge value) lounge,
    required TResult Function(_Hall value) hall,
    required TResult Function(_Study value) study,
    required TResult Function(_Library value) library,
    required TResult Function(_Billiard value) billiard,
  }) {
    return billiard(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Kitchen value)? kitchen,
    TResult Function(_Ballroom value)? ballroom,
    TResult Function(_Conservatory value)? conservatory,
    TResult Function(_DiningRoom value)? diningRoom,
    TResult Function(_Lounge value)? lounge,
    TResult Function(_Hall value)? hall,
    TResult Function(_Study value)? study,
    TResult Function(_Library value)? library,
    TResult Function(_Billiard value)? billiard,
    required TResult orElse(),
  }) {
    if (billiard != null) {
      return billiard(this);
    }
    return orElse();
  }
}

abstract class _Billiard implements Room {
  const factory _Billiard() = _$_Billiard;
}
